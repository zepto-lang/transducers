(load "transducers")
(load "minitest/minitest")
(define transducers:transduce (import "transducers:transduce"))
(define transducers:map (import "transducers:map"))
(define transducers:take (import "transducers:take"))
(define transducers:filter (import "transducers:filter"))
(define transducers:partition-by (import "transducers:partition-by"))
(define transducers:compose (import "transducers:compose"))
(define minitest:assert-equal (import "minitest:assert-equal"))
((import "minitest:colorize") #t)
((import "minitest:verbose") #t)

(minitest:assert-equal
  9
  (transducers:transduce (transducers:map add1) + 0 [1 2 3])
  "test that we can map and reduce with a transducer")

(minitest:assert-equal
  9
  (transducers:transduce (transducers:map add1) + 0 {1 2 3} vector:reduce)
  "test that we can transduce other collections")

(minitest:assert-equal
  1
  (transducers:transduce (transducers:take 1) + 0 [1 2 3])
  "test that we can take and reduce with a transducer")

(minitest:assert-equal
  [(1 1 1) (2 2 2) (1)]
  (transducers:transduce (transducers:partition-by id) += [] [1 1 1 2 2 2 1])
  "test that we can take and reduce with a transducer")

(minitest:assert-equal
  [1 1]
  (transducers:transduce (transducers:filter (curry eq? 1)) += [] [1 2 3 1])
  "test that we can filter with a transducer")

(minitest:assert-equal
  [2 3]
  (transducers:transduce
    (transducers:compose
      (transducers:map add1)
      (transducers:filter (lambda (x) (not (eq? 4 x)))))
    +=
    []
    [1 2 3])
  "test that we can compose transducers")

(minitest:assert-equal
  [2]
  (transducers:transduce
    (transducers:compose
      (transducers:map add1)
      (transducers:filter (lambda (x) (not (eq? 3 x))))
      (transducers:compose
        (transducers:filter (lambda (x) (not (eq? 4 x))))))
    +=
    []
    [1 2 3])
  "test that we can nest compositions")

((import "minitest:results"))
